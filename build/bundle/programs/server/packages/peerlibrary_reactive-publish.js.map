{"version":3,"sources":["meteor://ðŸ’»app/packages/peerlibrary_reactive-publish/packages/peerlibrary_reactive-publish.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/peerlibrary_reactive-publish.js","sourcesContent":["(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/peerlibrary:reactive-publish/publish.js                                                                    //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// Copy of code from Subscription.prototype._runHandler from ddp-server/livedata_server.js.                            // 1\n// See https://github.com/meteor/meteor/pull/5212                                                                      // 2\n                                                                                                                       // 3\npublishHandlerResult = function (self, res) {                                                                          // 4\n  // SPECIAL CASE: Instead of writing their own callbacks that invoke                                                  // 5\n  // this.added/changed/ready/etc, the user can just return a collection                                               // 6\n  // cursor or array of cursors from the publish function; we call their                                               // 7\n  // _publishCursor method which starts observing the cursor and publishes the                                         // 8\n  // results. Note that _publishCursor does NOT call ready().                                                          // 9\n  //                                                                                                                   // 10\n  // XXX This uses an undocumented interface which only the Mongo cursor                                               // 11\n  // interface publishes. Should we make this interface public and encourage                                           // 12\n  // users to implement it themselves? Arguably, it's unnecessary; users can                                           // 13\n  // already write their own functions like                                                                            // 14\n  //   var publishMyReactiveThingy = function (name, handler) {                                                        // 15\n  //     Meteor.publish(name, function () {                                                                            // 16\n  //       var reactiveThingy = handler();                                                                             // 17\n  //       reactiveThingy.publishMe();                                                                                 // 18\n  //     });                                                                                                           // 19\n  //   };                                                                                                              // 20\n  var isCursor = function (c) {                                                                                        // 21\n    return c && c._publishCursor;                                                                                      // 22\n  };                                                                                                                   // 23\n  if (isCursor(res)) {                                                                                                 // 24\n    try {                                                                                                              // 25\n      res._publishCursor(self);                                                                                        // 26\n    } catch (e) {                                                                                                      // 27\n      self.error(e);                                                                                                   // 28\n      return;                                                                                                          // 29\n    }                                                                                                                  // 30\n    // _publishCursor only returns after the initial added callbacks have run.                                         // 31\n    // mark subscription as ready.                                                                                     // 32\n    self.ready();                                                                                                      // 33\n  } else if (_.isArray(res)) {                                                                                         // 34\n    // check all the elements are cursors                                                                              // 35\n    if (! _.all(res, isCursor)) {                                                                                      // 36\n      self.error(new Error(\"Publish function returned an array of non-Cursors\"));                                      // 37\n      return;                                                                                                          // 38\n    }                                                                                                                  // 39\n    // find duplicate collection names                                                                                 // 40\n    // XXX we should support overlapping cursors, but that would require the                                           // 41\n    // merge box to allow overlap within a subscription                                                                // 42\n    var collectionNames = {};                                                                                          // 43\n    for (var i = 0; i < res.length; ++i) {                                                                             // 44\n      var collectionName = res[i]._getCollectionName();                                                                // 45\n      if (_.has(collectionNames, collectionName)) {                                                                    // 46\n        self.error(new Error(                                                                                          // 47\n          \"Publish function returned multiple cursors for collection \" +                                               // 48\n            collectionName));                                                                                          // 49\n        return;                                                                                                        // 50\n      }                                                                                                                // 51\n      collectionNames[collectionName] = true;                                                                          // 52\n    };                                                                                                                 // 53\n                                                                                                                       // 54\n    try {                                                                                                              // 55\n      _.each(res, function (cur) {                                                                                     // 56\n        cur._publishCursor(self);                                                                                      // 57\n      });                                                                                                              // 58\n    } catch (e) {                                                                                                      // 59\n      self.error(e);                                                                                                   // 60\n      return;                                                                                                          // 61\n    }                                                                                                                  // 62\n    self.ready();                                                                                                      // 63\n  } else if (res) {                                                                                                    // 64\n    // truthy values other than cursors or arrays are probably a                                                       // 65\n    // user mistake (possible returning a Mongo document via, say,                                                     // 66\n    // `coll.findOne()`).                                                                                              // 67\n    self.error(new Error(\"Publish function can only return a Cursor or \"                                               // 68\n                         + \"an array of Cursors\"));                                                                    // 69\n  }                                                                                                                    // 70\n};                                                                                                                     // 71\n                                                                                                                       // 72\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/peerlibrary:reactive-publish/server.coffee.js                                                              //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar Fiber, checkNames, originalLocalCollectionCursorObserveChanges, originalObserveChanges, originalPublish, wrapCallbacks,\n  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n  __slice = [].slice;\n\nFiber = Npm.require('fibers');\n\ncheckNames = function(publish, collectionNames, computation, result) {\n  var collectionName, computationId, cursor, names, resultNames, _i, _len;\n  if (result && _.isArray(result)) {\n    resultNames = (function() {\n      var _i, _len, _results;\n      _results = [];\n      for (_i = 0, _len = result.length; _i < _len; _i++) {\n        cursor = result[_i];\n        if ('_getCollectionName' in cursor) {\n          _results.push(cursor._getCollectionName());\n        }\n      }\n      return _results;\n    })();\n  } else if (result && '_getCollectionName' in result) {\n    resultNames = [result._getCollectionName()];\n  } else {\n    resultNames = [];\n  }\n  if (computation) {\n    collectionNames[computation._id] = resultNames;\n  }\n  for (computationId in collectionNames) {\n    names = collectionNames[computationId];\n    if (!computation || computationId !== (\"\" + computation._id)) {\n      for (_i = 0, _len = names.length; _i < _len; _i++) {\n        collectionName = names[_i];\n        if (!(__indexOf.call(resultNames, collectionName) >= 0)) {\n          continue;\n        }\n        publish.error(new Error(\"Multiple cursors for collection '\" + collectionName + \"'\"));\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\nwrapCallbacks = function(callbacks, initializingReference) {\n  var callback, callbackName, currentComputation;\n  if (Tracker.active) {\n    Meteor._nodeCodeMustBeInFiber();\n    currentComputation = Tracker.currentComputation;\n    callbacks = _.clone(callbacks);\n    for (callbackName in callbacks) {\n      callback = callbacks[callbackName];\n      if (callbackName === 'added' || callbackName === 'changed' || callbackName === 'removed' || callbackName === 'addedBefore' || callbackName === 'movedBefore') {\n        (function(callbackName, callback) {\n          return callbacks[callbackName] = function() {\n            var args, previousPublishComputation;\n            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n            if (initializingReference.initializing) {\n              previousPublishComputation = Fiber.current._publishComputation;\n              Fiber.current._publishComputation = currentComputation;\n              try {\n                return callback.apply(null, args);\n              } finally {\n                Fiber.current._publishComputation = previousPublishComputation;\n              }\n            } else {\n              return callback.apply(null, args);\n            }\n          };\n        })(callbackName, callback);\n      }\n    }\n  }\n  return callbacks;\n};\n\noriginalObserveChanges = MongoInternals.Connection.prototype._observeChanges;\n\nMongoInternals.Connection.prototype._observeChanges = function(cursorDescription, ordered, callbacks) {\n  var handle, initializing;\n  initializing = true;\n  callbacks = wrapCallbacks(callbacks, {\n    initializing: initializing\n  });\n  handle = originalObserveChanges.call(this, cursorDescription, ordered, callbacks);\n  initializing = false;\n  return handle;\n};\n\noriginalLocalCollectionCursorObserveChanges = LocalCollection.Cursor.prototype.observeChanges;\n\nLocalCollection.Cursor.prototype.observeChanges = function(options) {\n  var handle, initializing;\n  initializing = true;\n  options = wrapCallbacks(options, {\n    initializing: initializing\n  });\n  handle = originalLocalCollectionCursorObserveChanges.call(this, options);\n  initializing = false;\n  return handle;\n};\n\noriginalPublish = Meteor.publish;\n\nMeteor.publish = function(name, publishFunction) {\n  return originalPublish(name, function() {\n    var args, collectionNames, documents, handles, oldDocuments, originalAdded, originalReady, publish, ready, result;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    publish = this;\n    oldDocuments = {};\n    documents = {};\n    collectionNames = {};\n    publish._currentComputation = function() {\n      if (Tracker.active) {\n        return Tracker.currentComputation;\n      } else {\n        return Fiber.current._publishComputation;\n      }\n      return null;\n    };\n    publish._installCallbacks = function() {\n      var computation;\n      computation = this._currentComputation();\n      if (!computation) {\n        return;\n      }\n      if (!computation._publishOnStopSet) {\n        computation._publishOnStopSet = true;\n        computation.onStop((function(_this) {\n          return function() {\n            delete oldDocuments[computation._id];\n            return delete documents[computation._id];\n          };\n        })(this));\n      }\n      if (!computation._publishAfterRunSet) {\n        computation._publishAfterRunSet = true;\n        computation.afterRun((function(_this) {\n          return function() {\n            var collectionName, computationId, currentComputationAddedDocumentIds, currentlyPublishedDocumentIds, docs, id, otherComputationsAddedDocumentsIds, otherComputationsPreviouslyAddedDocumentsIds, _i, _len, _ref, _ref1;\n            for (collectionName in _this._documents) {\n              currentlyPublishedDocumentIds = _.keys(_this._documents[collectionName] || {});\n              currentComputationAddedDocumentIds = _.keys(((_ref = documents[computation._id]) != null ? _ref[collectionName] : void 0) || {});\n              otherComputationsAddedDocumentsIds = _.union.apply(_, (function() {\n                var _results;\n                _results = [];\n                for (computationId in documents) {\n                  docs = documents[computationId];\n                  if (computationId !== (\"\" + computation._id)) {\n                    _results.push(_.keys(docs[collectionName] || {}));\n                  }\n                }\n                return _results;\n              })());\n              otherComputationsPreviouslyAddedDocumentsIds = _.union.apply(_, (function() {\n                var _results;\n                _results = [];\n                for (computationId in oldDocuments) {\n                  docs = oldDocuments[computationId];\n                  if (computationId !== (\"\" + computation._id)) {\n                    _results.push(_.keys(docs[collectionName] || {}));\n                  }\n                }\n                return _results;\n              })());\n              _ref1 = _.difference(currentlyPublishedDocumentIds, currentComputationAddedDocumentIds, otherComputationsAddedDocumentsIds, otherComputationsPreviouslyAddedDocumentsIds);\n              for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n                id = _ref1[_i];\n                _this.removed(collectionName, _this._idFilter.idParse(id));\n              }\n            }\n            computation.beforeRun(function() {\n              oldDocuments[computation._id] = documents[computation._id] || {};\n              return documents[computation._id] = {};\n            });\n            return computation._publishAfterRunSet = false;\n          };\n        })(this));\n        computation._trackerInstance.requireFlush();\n      }\n    };\n    originalAdded = publish.added;\n    publish.added = function(collectionName, id, fields) {\n      var currentComputation, field, oldFields, stringId, _ref, _ref1, _ref2, _ref3;\n      stringId = this._idFilter.idStringify(id);\n      this._installCallbacks();\n      currentComputation = this._currentComputation();\n      if (currentComputation) {\n        Meteor._ensure(documents, currentComputation._id, collectionName)[stringId] = true;\n      }\n      if ((_ref = this._documents[collectionName]) != null ? _ref[stringId] : void 0) {\n        oldFields = {};\n        for (field in ((_ref1 = this._session.getCollectionView(collectionName)) != null ? (_ref2 = _ref1.documents) != null ? (_ref3 = _ref2[stringId]) != null ? _ref3.dataByKey : void 0 : void 0 : void 0) || {}) {\n          oldFields[field] = void 0;\n        }\n        return this.changed(collectionName, id, _.extend(oldFields, fields));\n      } else {\n        return originalAdded.call(this, collectionName, id, fields);\n      }\n    };\n    ready = false;\n    originalReady = publish.ready;\n    publish.ready = function() {\n      this._installCallbacks();\n      if (!ready) {\n        originalReady.call(this);\n      }\n      ready = true;\n    };\n    handles = [];\n    publish.autorun = function(runFunc) {\n      var handle;\n      handle = Tracker.autorun(function(computation) {\n        var result;\n        result = runFunc.call(publish, computation);\n        if (!checkNames(publish, collectionNames, computation, result)) {\n          computation.stop();\n          return;\n        }\n        if (result instanceof Tracker.Computation) {\n          if (publish._isDeactivated()) {\n            return result.stop();\n          } else {\n            return handles.push(result);\n          }\n        } else {\n          if (!publish._isDeactivated()) {\n            return publishHandlerResult(publish, result);\n          }\n        }\n      });\n      handles.push(handle);\n      return handle;\n    };\n    publish.onStop(function() {\n      var handle, _results;\n      _results = [];\n      while (handles.length) {\n        handle = handles.shift();\n        _results.push(handle != null ? handle.stop() : void 0);\n      }\n      return _results;\n    });\n    result = publishFunction.apply(publish, args);\n    if (!checkNames(publish, collectionNames, null, result)) {\n      return;\n    }\n    if (result instanceof Tracker.Computation) {\n      handles.push(result);\n    } else {\n      return result;\n    }\n  });\n};\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}