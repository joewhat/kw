{"version":3,"sources":["meteor://ðŸ’»app/packages/peerlibrary_server-autorun/packages/peerlibrary_server-autorun.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/peerlibrary_server-autorun.js","sourcesContent":["(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                     //\n// packages/peerlibrary:server-autorun/server.coffee.js                                                //\n//                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                       //\n__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar Fiber, Future, TrackerInstance, guard, nextId, privateObject;\n\nFiber = Npm.require('fibers');\n\nFuture = Npm.require('fibers/future');\n\nprivateObject = {};\n\nguard = {};\n\nnextId = 1;\n\nTrackerInstance = (function() {\n  function TrackerInstance() {\n    this.active = false;\n    this.currentComputation = null;\n    this.pendingComputations = [];\n    this.willFlush = false;\n    this.inFlush = null;\n    this.inRequireFlush = false;\n    this.inCompute = false;\n    this.throwFirstError = false;\n    this.afterFlushCallbacks = [];\n  }\n\n  TrackerInstance.prototype.setCurrentComputation = function(computation) {\n    this.currentComputation = computation;\n    return this.active = !!computation;\n  };\n\n  TrackerInstance.prototype._debugFunc = function() {\n    if (typeof Meteor !== \"undefined\" && Meteor !== null ? Meteor._debug : void 0) {\n      return Meteor._debug;\n    }\n    if (typeof console !== \"undefined\" && console !== null ? console.error : void 0) {\n      return function() {\n        return console.error.apply(console, arguments);\n      };\n    }\n    return function() {};\n  };\n\n  TrackerInstance.prototype._maybeSuppressMoreLogs = function(messagesLength) {\n    if (typeof Meteor !== \"undefined\") {\n      if (Meteor._suppressed_log_expected()) {\n        return Meteor._suppress_log(messagesLength - 1);\n      }\n    }\n  };\n\n  TrackerInstance.prototype._throwOrLog = function(from, error) {\n    var idx, message, printArg, printArgs, _i, _len, _results;\n    if (this.throwFirstError) {\n      throw error;\n    } else {\n      printArgs = [\"Exception from Tracker \" + from + \" function:\"];\n      if (error.stack && error.message && error.name) {\n        idx = error.stack.indexOf(error.message);\n        if (idx < 0 || idx > error.name.length + 2) {\n          message = error.name + \": \" + error.message;\n          printArgs.push(message);\n        }\n      }\n      printArgs.push(error.stack);\n      this._maybeSuppressMoreLogs(printArgs.length);\n      _results = [];\n      for (_i = 0, _len = printArgs.length; _i < _len; _i++) {\n        printArg = printArgs[_i];\n        _results.push(this._debugFunc()(printArg));\n      }\n      return _results;\n    }\n  };\n\n  TrackerInstance.prototype._deferAndTransfer = function(func) {\n    return Meteor.defer((function(_this) {\n      return function() {\n        assert(!Fiber.current._trackerInstance);\n        try {\n          Fiber.current._trackerInstance = _this;\n          return func();\n        } finally {\n          Fiber.current._trackerInstance = null;\n        }\n      };\n    })(this));\n  };\n\n  TrackerInstance.prototype.requireFlush = function() {\n    if (this.willFlush) {\n      return;\n    }\n    this._deferAndTransfer((function(_this) {\n      return function() {\n        return _this._runFlush({\n          fromRequireFlush: true\n        });\n      };\n    })(this));\n    return this.willFlush = true;\n  };\n\n  TrackerInstance.prototype._runFlush = function(options) {\n    var computation, error, finishedTry, func, inFlush, recomputedCount;\n    if (this.inFlush instanceof Future) {\n      if (options != null ? options.fromRequireFlush : void 0) {\n        return;\n      }\n      this.inFlush.wait();\n      assert(!this.inFlush);\n    }\n    if (this.inFlush && (options != null ? options.fromRequireFlush : void 0)) {\n      return;\n    }\n    if (this.inFlush) {\n      throw new Error(\"Can't call Tracker.flush while flushing\");\n    }\n    if (this.inCompute) {\n      if (options != null ? options.fromRequireFlush : void 0) {\n        this._deferAndTransfer((function(_this) {\n          return function() {\n            return _this._runFlush(options);\n          };\n        })(this));\n        return;\n      }\n      throw new Error(\"Can't flush inside Tracker.autorun\");\n    }\n    if (options != null ? options.fromRequireFlush : void 0) {\n      this.inFlush = new Future();\n    } else {\n      this.inFlush = true;\n    }\n    this.willFlush = true;\n    this.throwFirstError = !!(options != null ? options.throwFirstError : void 0);\n    recomputedCount = 0;\n    finishedTry = false;\n    try {\n      while (this.pendingComputations.length || this.afterFlushCallbacks.length) {\n        while (this.pendingComputations.length) {\n          computation = this.pendingComputations.shift();\n          computation._recompute();\n          if (computation._needsRecompute()) {\n            this.pendingComputations.unshift(computation);\n          }\n          if (!(options != null ? options.finishSynchronously : void 0) && ++recomputedCount > 1000) {\n            finishedTry = true;\n            return;\n          }\n        }\n        if (this.afterFlushCallbacks.length) {\n          func = this.afterFlushCallbacks.shift();\n          try {\n            func();\n          } catch (_error) {\n            error = _error;\n            this._throwOrLog(\"afterFlush\", error);\n          }\n        }\n      }\n      return finishedTry = true;\n    } finally {\n      inFlush = this.inFlush;\n      if (!finishedTry) {\n        this.inFlush = null;\n        if (inFlush instanceof Future) {\n          inFlush[\"return\"]();\n        }\n        this._runFlush({\n          finishSynchronously: options != null ? options.finishSynchronously : void 0,\n          throwFirstError: false\n        });\n      }\n      this.willFlush = false;\n      this.inFlush = null;\n      if (inFlush instanceof Future) {\n        inFlush[\"return\"]();\n      }\n      if (this.pendingComputations.length || this.afterFlushCallbacks.length) {\n        if (options != null ? options.finishSynchronously : void 0) {\n          throw new Error(\"still have more to do?\");\n        }\n        Meteor.setTimeout((function(_this) {\n          return function() {\n            return _this.requireFlush();\n          };\n        })(this), 10);\n      }\n    }\n  };\n\n  return TrackerInstance;\n\n})();\n\nTracker._computations = {};\n\nTracker._trackerInstance = function() {\n  var _base;\n  Meteor._nodeCodeMustBeInFiber();\n  return (_base = Fiber.current)._trackerInstance != null ? _base._trackerInstance : _base._trackerInstance = new TrackerInstance();\n};\n\nTracker.flush = function(options) {\n  return Tracker._trackerInstance()._runFlush({\n    finishSynchronously: true,\n    throwFirstError: options != null ? options._throwFirstError : void 0\n  });\n};\n\nTracker.autorun = function(func, options) {\n  var c;\n  if (typeof func !== \"function\") {\n    throw new Error(\"Tracker.autorun requires a function argument\");\n  }\n  c = new Tracker.Computation(func, Tracker.currentComputation, options != null ? options.onError : void 0, privateObject);\n  if (Tracker.active) {\n    Tracker.onInvalidate(function() {\n      return c.stop();\n    });\n  }\n  return c;\n};\n\nTracker.nonreactive = function(f) {\n  var previous, trackerInstance;\n  trackerInstance = Tracker._trackerInstance();\n  previous = trackerInstance.currentComputation;\n  trackerInstance.setCurrentComputation(null);\n  try {\n    return f();\n  } finally {\n    trackerInstance.setCurrentComputation(previous);\n  }\n};\n\nTracker.onInvalidate = function(f) {\n  if (!Tracker.active) {\n    throw new Error(\"Tracker.onInvalidate requires a currentComputation\");\n  }\n  return Tracker.currentComputation.onInvalidate(f);\n};\n\nTracker.afterFlush = function(f) {\n  var trackerInstance;\n  trackerInstance = Tracker._trackerInstance();\n  trackerInstance.afterFlushCallbacks.push(f);\n  return trackerInstance.requireFlush();\n};\n\nObject.defineProperties(Tracker, {\n  currentComputation: {\n    get: function() {\n      return Tracker._trackerInstance().currentComputation;\n    }\n  },\n  active: {\n    get: function() {\n      return Tracker._trackerInstance().active;\n    }\n  }\n});\n\nTracker.Computation = (function() {\n  function Computation(func, _parent, _onError, _private) {\n    var errored, onException;\n    this._parent = _parent;\n    this._onError = _onError;\n    if (_private !== privateObject) {\n      throw new Error(\"Tracker.Computation constructor is private; use Tracker.autorun\");\n    }\n    this.stopped = false;\n    this.invalidated = false;\n    this.firstRun = true;\n    this._id = nextId++;\n    this._onInvalidateCallbacks = [];\n    this._onStopCallbacks = [];\n    this._beforeRunCallbacks = [];\n    this._afterRunCallbacks = [];\n    this._recomputing = false;\n    this._trackerInstance = Tracker._trackerInstance();\n    onException = (function(_this) {\n      return function(error) {\n        if (_this.firstRun) {\n          throw error;\n        }\n        if (_this._onError) {\n          return _this._onError(error);\n        } else {\n          return _this._trackerInstance._throwOrLog(\"recompute\", error);\n        }\n      };\n    })(this);\n    this._func = Meteor.bindEnvironment(func, onException, this);\n    Tracker._computations[this._id] = this;\n    errored = true;\n    try {\n      this._compute();\n      errored = false;\n    } finally {\n      this.firstRun = false;\n      if (errored) {\n        this.stop();\n      }\n    }\n  }\n\n  Computation.prototype.onInvalidate = function(f) {\n    return FiberUtils.ensureFiber((function(_this) {\n      return function() {\n        if (typeof f !== \"function\") {\n          throw new Error(\"onInvalidate requires a function\");\n        }\n        if (_this.invalidated) {\n          return Tracker.nonreactive(function() {\n            return f(_this);\n          });\n        } else {\n          return _this._onInvalidateCallbacks.push(f);\n        }\n      };\n    })(this));\n  };\n\n  Computation.prototype.onStop = function(f) {\n    return FiberUtils.ensureFiber((function(_this) {\n      return function() {\n        if (typeof f !== \"function\") {\n          throw new Error(\"onStop requires a function\");\n        }\n        if (_this.stopped) {\n          return Tracker.nonreactive(function() {\n            return f(_this);\n          });\n        } else {\n          return _this._onStopCallbacks.push(f);\n        }\n      };\n    })(this));\n  };\n\n  Computation.prototype.beforeRun = function(f) {\n    if (typeof f !== \"function\") {\n      throw new Error(\"beforeRun requires a function\");\n    }\n    return this._beforeRunCallbacks.push(f);\n  };\n\n  Computation.prototype.afterRun = function(f) {\n    if (typeof f !== \"function\") {\n      throw new Error(\"afterRun requires a function\");\n    }\n    return this._afterRunCallbacks.push(f);\n  };\n\n  Computation.prototype.invalidate = function() {\n    return FiberUtils.ensureFiber((function(_this) {\n      return function() {\n        var callback, _i, _len, _ref;\n        if (!_this.invalidated) {\n          if (!_this._recomputing && !_this.stopped) {\n            _this._trackerInstance.requireFlush();\n            _this._trackerInstance.pendingComputations.push(_this);\n          }\n          _this.invalidated = true;\n          _ref = _this._onInvalidateCallbacks;\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            callback = _ref[_i];\n            Tracker.nonreactive(function() {\n              return callback(_this);\n            });\n          }\n          return _this._onInvalidateCallbacks = [];\n        }\n      };\n    })(this));\n  };\n\n  Computation.prototype.stop = function() {\n    return FiberUtils.ensureFiber((function(_this) {\n      return function() {\n        return FiberUtils.synchronize(guard, _this._id, function() {\n          var callback, _results;\n          if (_this.stopped) {\n            return;\n          }\n          _this.stopped = true;\n          _this.invalidate();\n          delete Tracker._computations[_this._id];\n          _results = [];\n          while (_this._onStopCallbacks.length) {\n            callback = _this._onStopCallbacks.shift();\n            _results.push(Tracker.nonreactive(function() {\n              return callback(_this);\n            }));\n          }\n          return _results;\n        });\n      };\n    })(this));\n  };\n\n  Computation.prototype._runInside = function(func) {\n    return FiberUtils.synchronize(guard, this._id, (function(_this) {\n      return function() {\n        var previousComputation, previousInCompute, previousTrackerInstance;\n        Meteor._nodeCodeMustBeInFiber();\n        previousTrackerInstance = Tracker._trackerInstance();\n        Fiber.current._trackerInstance = _this._trackerInstance;\n        previousComputation = _this._trackerInstance.currentComputation;\n        _this._trackerInstance.setCurrentComputation(_this);\n        previousInCompute = _this._trackerInstance.inCompute;\n        _this._trackerInstance.inCompute = true;\n        try {\n          return func(_this);\n        } finally {\n          Fiber.current._trackerInstance = previousTrackerInstance;\n          _this._trackerInstance.setCurrentComputation(previousComputation);\n          _this._trackerInstance.inCompute = previousInCompute;\n        }\n      };\n    })(this));\n  };\n\n  Computation.prototype._compute = function() {\n    return FiberUtils.synchronize(guard, this._id, (function(_this) {\n      return function() {\n        _this.invalidated = false;\n        return _this._runInside(function(computation) {\n          var callback, _results;\n          while (_this._beforeRunCallbacks.length) {\n            callback = _this._beforeRunCallbacks.shift();\n            Tracker.nonreactive(function() {\n              return callback(_this);\n            });\n          }\n          _this._func.call(null, _this);\n          _results = [];\n          while (_this._afterRunCallbacks.length) {\n            callback = _this._afterRunCallbacks.shift();\n            _results.push(Tracker.nonreactive(function() {\n              return callback(_this);\n            }));\n          }\n          return _results;\n        });\n      };\n    })(this));\n  };\n\n  Computation.prototype._needsRecompute = function() {\n    return this.invalidated && !this.stopped;\n  };\n\n  Computation.prototype._recompute = function() {\n    return FiberUtils.synchronize(guard, this._id, (function(_this) {\n      return function() {\n        assert(!_this._recomputing);\n        _this._recomputing = true;\n        try {\n          if (_this._needsRecompute()) {\n            return _this._compute();\n          }\n        } finally {\n          _this._recomputing = false;\n        }\n      };\n    })(this));\n  };\n\n  Computation.prototype.flush = function() {\n    return FiberUtils.ensureFiber((function(_this) {\n      return function() {\n        if (_this._recomputing) {\n          return;\n        }\n        return _this._recompute();\n      };\n    })(this));\n  };\n\n  Computation.prototype.run = function() {\n    return FiberUtils.ensureFiber((function(_this) {\n      return function() {\n        _this.invalidate();\n        return _this.flush();\n      };\n    })(this));\n  };\n\n  return Computation;\n\n})();\n\nTracker.Dependency = (function() {\n  function Dependency() {\n    this._dependentsById = {};\n  }\n\n  Dependency.prototype.depend = function(computation) {\n    var id;\n    if (!computation) {\n      if (!Tracker.active) {\n        return false;\n      }\n      computation = Tracker.currentComputation;\n    }\n    id = computation._id;\n    if (!(id in this._dependentsById)) {\n      this._dependentsById[id] = computation;\n      computation.onInvalidate((function(_this) {\n        return function() {\n          return delete _this._dependentsById[id];\n        };\n      })(this));\n      return true;\n    }\n    return false;\n  };\n\n  Dependency.prototype.changed = function() {\n    var computation, id, _ref, _results;\n    _ref = this._dependentsById;\n    _results = [];\n    for (id in _ref) {\n      computation = _ref[id];\n      _results.push(computation.invalidate());\n    }\n    return _results;\n  };\n\n  Dependency.prototype.hasDependents = function() {\n    var computation, id, _ref;\n    _ref = this._dependentsById;\n    for (id in _ref) {\n      computation = _ref[id];\n      return true;\n    }\n    return false;\n  };\n\n  return Dependency;\n\n})();\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}